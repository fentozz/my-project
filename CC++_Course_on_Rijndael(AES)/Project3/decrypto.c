#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <memory.h>



#define _CRT_SECURE_NO_WARNINGS

//Количество столбцов, содержащих состояние в AES
#define Nb 4

//Количество раундов
int Nr_ = 0;
//Количество 32-битных слов в ключе
int Nk_ = 0;

// in_ - это массив, который содержит зашифрованный текст для дешифрования.
// out_ - это массив, который содержит выходные данные для расшифровки.
// state_ - массив, который содержит промежуточные результаты во время расшифровки.
unsigned char in_[16], out_[16], state_[4][4];

// Массив, в котором хранятся раундовые ключи.
unsigned char RoundKey_[240];
//ключ расшифровки
unsigned char Key_[32];

int getSBoxInvert_(int num)
{
	int rsbox_[256] =
	{ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb
	, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb
	, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e
	, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25
	, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92
	, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84
	, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06
	, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b
	, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73
	, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e
	, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b
	, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4
	, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f
	, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef
	, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61
	, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };

	return rsbox_[num];
}

int getSBoxValue_(int num)
{
	int sbox_[256] = {
		//0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
	return sbox_[num];
}


int Rcon_[255] = {
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb };
// Эта функция создает Nb (Nr + 1) раундовых ключей. Раундовые ключи используются в каждом раунде для расшифровки состояний.
void KeyExpansion_()
{
	int i, j;
	unsigned char temp[4], k;

	// Ключ первого раунда это сам ключ
	for (i = 0; i < Nk_; i++)
	{
		RoundKey_[i * 4] = Key_[i * 4];
		RoundKey_[i * 4 + 1] = Key_[i * 4 + 1];
		RoundKey_[i * 4 + 2] = Key_[i * 4 + 2];
		RoundKey_[i * 4 + 3] = Key_[i * 4 + 3];
	}

	// Все остальные раундовые ключи находятся из предидущего
	while (i < (Nb * (Nr_ + 1)))
	{
		for (j = 0; j < 4; j++)
		{
			temp[j] = RoundKey_[(i - 1) * 4 + j];
		}
		if (i % Nk_ == 0)
		{
			// Эта функция поворачивает 4 байта в слове влево 
			// [a0,a1,a2,a3] становится [a1,a2,a3,a0]
			{
				k = temp[0];
				temp[0] = temp[1];
				temp[1] = temp[2];
				temp[2] = temp[3];
				temp[3] = k;
			}

			// это функция, которая принимает четырехбайтовое входное слово и
			// применяет S-блок к каждому из четырех байтов для создания выходного слова.
			{
				temp[0] = getSBoxValue_(temp[0]);
				temp[1] = getSBoxValue_(temp[1]);
				temp[2] = getSBoxValue_(temp[2]);
				temp[3] = getSBoxValue_(temp[3]);
			}

			temp[0] = temp[0] ^ Rcon_[i / Nk_];
		}
		else if (Nk_ > 6 && i % Nk_ == 4)
		{
			
			{
				temp[0] = getSBoxValue_(temp[0]);
				temp[1] = getSBoxValue_(temp[1]);
				temp[2] = getSBoxValue_(temp[2]);
				temp[3] = getSBoxValue_(temp[3]);
			}
		}
		RoundKey_[i * 4 + 0] = RoundKey_[(i - Nk_) * 4 + 0] ^ temp[0];
		RoundKey_[i * 4 + 1] = RoundKey_[(i - Nk_) * 4 + 1] ^ temp[1];
		RoundKey_[i * 4 + 2] = RoundKey_[(i - Nk_) * 4 + 2] ^ temp[2];
		RoundKey_[i * 4 + 3] = RoundKey_[(i - Nk_) * 4 + 3] ^ temp[3];
		i++;
	}
}

// добавляет раундовый ключ в состояние
// раундовый ключ добавляется в состояние функцией XOR.
void AddRoundKey_(int round)
{
	int i, j;
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			state_[j][i] ^= RoundKey_[round * Nb * 4 + i * Nb + j];
		}
	}
}

//подставляет значения в матрицу состояний из S-блока
//обратное действие
void InvSubBytes_()
{
	int i, j;
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			state_[i][j] = getSBoxInvert_(state_[i][j]);

		}
	}
}

// Функция сдвигает ряды состояний влево
// Каждый ряд сдвигается с разным смещением 
// смещение = номеру строки. первая строка не смещается
// производит обратное действие
void InvShiftRows_()
{
	unsigned char temp;
	//Поворачиваем первый ряд на 1 столбец вправо
	temp = state_[1][3];
	state_[1][3] = state_[1][2];
	state_[1][2] = state_[1][1];
	state_[1][1] = state_[1][0];
	state_[1][0] = temp;
	//Поворачиваем вторую строку на 2 столбца вправо
	temp = state_[2][0];
	state_[2][0] = state_[2][2];
	state_[2][2] = temp;

	temp = state_[2][1];
	state_[2][1] = state_[2][3];
	state_[2][3] = temp;

	//Повернуть третий ряд на 3 столбца вправо
	temp = state_[3][0];
	state_[3][0] = state_[3][1];
	state_[3][1] = state_[3][2];
	state_[3][2] = state_[3][3];
	state_[3][3] = temp;
}

//xtime - это макрос, который находит произведение{ 02 } и аргумент для xtime по модулю{ 1b }
#define xtime(x)   ((x<<1) ^ (((x>>7) & 1) * 0x1b))
// Multiplty - это макрос, используемый для умножения чисел в поле GF (2^8)
#define Multiply(x,y) (((y & 1) * x) ^ ((y>>1 & 1) * xtime(x)) ^ ((y>>2 & 1) * xtime(xtime(x))) ^ ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^ ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))

//функция производит обратное действие смещиванию матрицы состояний
void InvMixColumns_()
{
	int i;
	unsigned char a, b, c, d;
	for (i = 0; i < 4; i++)
	{

		a = state_[0][i];
		b = state_[1][i];
		c = state_[2][i];
		d = state_[3][i];


		state_[0][i] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
		state_[1][i] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
		state_[2][i] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
		state_[3][i] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
	}
}

//функция расшифровки
void InvCipher_()
{
	int i, j, round = 0;
	//копируем текст расшифровки в матрицу состояний
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			state_[j][i] = in_[i * 4 + j];
		}
	}
	// Добавить ключ первого раунда в состояние перед началом раундов
	AddRoundKey_(Nr_);

	// Nr - количество раундов
	// Первые раунды - идентичны (до Nr -1 )
	for (round = Nr_ - 1; round > 0; round--)
	{
		InvShiftRows_();
		InvSubBytes_();
		AddRoundKey_(round);
		InvMixColumns_();
	}
	// Последний раунд Nr
	// В последнем раунде не перемешиваются столбцы
	InvShiftRows_();
	InvSubBytes_();
	AddRoundKey_(0);
	
	//матрица состояний копируется в массив на выход
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			out_[i * 4 + j] = state_[j][i];
		}
	}
}

//точка входа при расшифровке
int core_decrypt(wchar_t CHarr[], int byte_col, char key_c[])
{
	//количество двойных слэшей
	int sp = 0;
	//длинна 
	int len = 0;

	for (int i = 0; CHarr[i] != '\0'; i++)
	{
		len++;
		if (CHarr[i] == '\\') sp++;
	}

	//строка пути хранения исходного файла
	char* str;
	str = (char*)malloc(len - sp);

	for (int i = 0; ; i++)
	{
		if (CHarr[i] == '\\') str[i] = '/';
		else if (CHarr[i] == '\0')
		{
			str[i] = '\0';
			break;
		}
		else str[i] = CHarr[i];
	}
	if (str == "") return 1;
	if (str[0] == '\0') return 1;
	//получили правильную строку
	errno_t err;
	FILE *mf; //подаваемый файл
	err = fopen_s(&mf, str, "rb");
	if (err != 0) return 1;

	//расшифрованный файл , конечный
	char* str_save;
	str_save = (char*)malloc(sizeof(char)*(strlen(str) - 6));
	int ffe = strlen(str) - 6;
	for (int i = 0; i < (strlen(str) - 6); i++)
	{
		str_save[i] = str[i];
		
	}
	str_save[ffe] = '\0';

	int pos = 0;
	for (pos = strlen(str_save); pos > 0; pos--)
		if (str_save[pos] == '/') break;

	if (pos != 0)
	{

		int i = 0;
		for ( i = pos + 1; i < strlen(str_save); i++)
			str[i-pos - 1] = str_save[i];
		str[i - pos -1 ] = '\0';

		str_save[pos+1] = 'd';
		str_save[pos+2] = 'e';
		str_save[pos+3] = 'c';
		str_save[pos+4] = 'r';
		str_save[pos+5] = 'y';
		str_save[pos+6] = 'p';
		str_save[pos+7] = 't';
		str_save[pos+8] = 'o';
		str_save[pos+9] = '_';

		for (i = 0; i < strlen(str); i++)
			str_save[pos + 10 + i] = str[i];
		str_save[pos + i + 10] = '\0';
	}
	//получили название для расшифрованного файла

	FILE *crypt;//конечный файл
	errno_t err_cr;
	err_cr = fopen_s(&crypt, str_save, "wb+");
	if (err_cr != 0) return 1;

	Nr_ = byte_col;//128;//192, 256 Длинна ключа в битах . 

	Nk_ = Nr_ / 32;
	Nr_ = Nk_ + 6;//количество раундов

	//массив для ключа
	unsigned char temp[32] = { 0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x0a  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00
							  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x0a  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00 };

	//считываем ключ
	for (int i = 0; i < strlen(key_c); i++)
	{
		temp[i] = key_c[i];
	}
	//записываем ключ 
	for (int i = 0; i < Nk_ * 4; i++)
	{
		Key_[i] = temp[i];
	}

	//текст на расшифровку буфера из двух массивов 
	unsigned char temp2[16] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
	unsigned char temp3[16] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

	int i_f_c;//считываемый байт
	unsigned int num = 0;//счетчик байтов для буферов
	unsigned int ne = 0; //используемый буфер
	unsigned int l_b = 0;//количество лишних байт в предпоследнем буфере\блоке

	fseek(mf, -1L, SEEK_END); //переходим вконец файла
	l_b = getc(mf); //получаем количество лишних символов с конца( мы записали их туда при зашифровке )
	rewind(mf);//переходим в начало файла
	while ((i_f_c = getc(mf)) != EOF)//читаем до конца файла
	{
		if (ne == 0) temp2[num] = i_f_c; //записываем в первый буфер
		else if (ne == 1) temp3[num] = i_f_c; //записываем во второй буфер
		num++; //двигаемся дальше

		//можно избежать этого если просто считать длинну файла (но это не интересно)

		if (num == 16 & ne == 0) //если первый буфер заполнен
		{
			ne++;
			num = 0;
		}
		else if (num == 16 & ne == 1)  //если второй буфер заполнен
		{
			int chk = 0;
			fseek(mf, 1L, SEEK_CUR);//перемещаемся на один символ в файле в право  и смотрим что там
			chk = getc(mf); //при считывании байта указатель сдвинеться , значит чтобы потом вернутся нужно будет вернуться на 2 байта
			if ((chk) != EOF)//если тут файл не кончается 
			{
				fseek(mf, -2L, SEEK_CUR); // перемещаемся обратно 
				//записываем наш первый считанный блок
				for (int i = 0; i < 16; i++)
				{
					in_[i] = temp2[i];
				}
				//расшифруем его
				KeyExpansion_();
				InvCipher_();
				for (int i = 0; i < 16; i++)
				{
					//записываем в конечный файл
					putc(out_[i], crypt);
				}

				for (int i = 0; i < 16; i++)
				{
					//записываем второй считанный блок
					in_[i] = temp3[i];
				}
				//расшифруем его
				KeyExpansion_();
				InvCipher_();
				for (int i = 0; i < 16; i++)
				{
					//записываем в конечный файл
					putc(out_[i], crypt);
				}
				ne = 0;
				num = 0;
			}
			else if ((chk ) == EOF) //если там конец файла
			{
				fseek(mf, -2L, SEEK_CUR);//возращаем указатель в файле обратно
				//записываем первый считанный блок
				for (int i = 0; i < 16; i++)
				{
					in_[i] = temp2[i];
				}
				//расшифруем его 
				KeyExpansion_();
				InvCipher_();
				for (int i = 0; i < 16; i++)
				{
					//записываем в конечный файл
					putc(out_[i], crypt);
				}

				for (int i = 0; i < 16; i++)
				{
					//запишем второй считанный блок в первый
					temp2[i] = temp3[i];
				}

				num = 0;
				ne = 1;
			}
		}
	}
	
	//обработка последнего блока
	if (l_b == 0) //если лишних символов небыло
	{
		//запишем последний блок
		for (int i = 0; i < 16; i++)
		{
			in_[i] = temp2[i];
		}
		//расшифруем его
		KeyExpansion_();
		InvCipher_();
		for (int i = 0; i < 16; i++)
		{
			//запишем в конечный файл 
			putc(out_[i], crypt);
		}
	}
	else //если лишние символы есть  
	{
		//запишем последний блок
		for (int i = 0; i < 16; i++)
		{
			in_[i] = temp2[i];
		}
		//расшифруем его 
		KeyExpansion_();
		InvCipher_();
		//запишем байты в конечный файл за вычетом ненужных
		for (int i = 0; i < 16 - l_b; i++)
		{
			putc(out_[i], crypt);
		}
	}

	fclose(mf);
	fclose(crypt);
	return 0;
}