#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <malloc.h>
#include <stdlib.h>
#include <memory.h>



#define _CRT_SECURE_NO_WARNINGS

#define Nb 4

int Nr_ = 0;

int Nk_ = 0;

unsigned char in_[16], out_[16], state_[4][4];

unsigned char RoundKey_[240];

unsigned char Key_[32];

int getSBoxInvert_(int num)
{
	int rsbox_[256] =
	{ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb
	, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb
	, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e
	, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25
	, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92
	, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84
	, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06
	, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b
	, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73
	, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e
	, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b
	, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4
	, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f
	, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef
	, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61
	, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };

	return rsbox_[num];
}

int getSBoxValue_(int num)
{
	int sbox_[256] = {
		//0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
	return sbox_[num];
}


int Rcon_[255] = {
	0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb };

void KeyExpansion_()
{
	int i, j;
	unsigned char temp[4], k;

	// The first round key is the key itself.
	for (i = 0; i < Nk_; i++)
	{
		RoundKey_[i * 4] = Key_[i * 4];
		RoundKey_[i * 4 + 1] = Key_[i * 4 + 1];
		RoundKey_[i * 4 + 2] = Key_[i * 4 + 2];
		RoundKey_[i * 4 + 3] = Key_[i * 4 + 3];
	}

	// All other round keys are found from the previous round keys.
	while (i < (Nb * (Nr_ + 1)))
	{
		for (j = 0; j < 4; j++)
		{
			temp[j] = RoundKey_[(i - 1) * 4 + j];
		}
		if (i % Nk_ == 0)
		{
			// This function rotates the 4 bytes in a word to the left once.
			// [a0,a1,a2,a3] becomes [a1,a2,a3,a0]

			// Function RotWord()
			{
				k = temp[0];
				temp[0] = temp[1];
				temp[1] = temp[2];
				temp[2] = temp[3];
				temp[3] = k;
			}

			// SubWord() is a function that takes a four-byte input word and 
			// applies the S-box to each of the four bytes to produce an output word.

			// Function Subword()
			{
				temp[0] = getSBoxValue_(temp[0]);
				temp[1] = getSBoxValue_(temp[1]);
				temp[2] = getSBoxValue_(temp[2]);
				temp[3] = getSBoxValue_(temp[3]);
			}

			temp[0] = temp[0] ^ Rcon_[i / Nk_];
		}
		else if (Nk_ > 6 && i % Nk_ == 4)
		{
			// Function Subword()
			{
				temp[0] = getSBoxValue_(temp[0]);
				temp[1] = getSBoxValue_(temp[1]);
				temp[2] = getSBoxValue_(temp[2]);
				temp[3] = getSBoxValue_(temp[3]);
			}
		}
		RoundKey_[i * 4 + 0] = RoundKey_[(i - Nk_) * 4 + 0] ^ temp[0];
		RoundKey_[i * 4 + 1] = RoundKey_[(i - Nk_) * 4 + 1] ^ temp[1];
		RoundKey_[i * 4 + 2] = RoundKey_[(i - Nk_) * 4 + 2] ^ temp[2];
		RoundKey_[i * 4 + 3] = RoundKey_[(i - Nk_) * 4 + 3] ^ temp[3];
		i++;
	}
}


void AddRoundKey_(int round)
{
	int i, j;
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			state_[j][i] ^= RoundKey_[round * Nb * 4 + i * Nb + j];
		}
	}
}

void InvSubBytes_()
{
	int i, j;
	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			state_[i][j] = getSBoxInvert_(state_[i][j]);

		}
	}
}

void InvShiftRows_()
{
	unsigned char temp;

	temp = state_[1][3];
	state_[1][3] = state_[1][2];
	state_[1][2] = state_[1][1];
	state_[1][1] = state_[1][0];
	state_[1][0] = temp;

	temp = state_[2][0];
	state_[2][0] = state_[2][2];
	state_[2][2] = temp;

	temp = state_[2][1];
	state_[2][1] = state_[2][3];
	state_[2][3] = temp;

	temp = state_[3][0];
	state_[3][0] = state_[3][1];
	state_[3][1] = state_[3][2];
	state_[3][2] = state_[3][3];
	state_[3][3] = temp;
}


#define xtime(x)   ((x<<1) ^ (((x>>7) & 1) * 0x1b))

#define Multiply(x,y) (((y & 1) * x) ^ ((y>>1 & 1) * xtime(x)) ^ ((y>>2 & 1) * xtime(xtime(x))) ^ ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^ ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))

void InvMixColumns_()
{
	int i;
	unsigned char a, b, c, d;
	for (i = 0; i < 4; i++)
	{

		a = state_[0][i];
		b = state_[1][i];
		c = state_[2][i];
		d = state_[3][i];


		state_[0][i] = Multiply(a, 0x0e) ^ Multiply(b, 0x0b) ^ Multiply(c, 0x0d) ^ Multiply(d, 0x09);
		state_[1][i] = Multiply(a, 0x09) ^ Multiply(b, 0x0e) ^ Multiply(c, 0x0b) ^ Multiply(d, 0x0d);
		state_[2][i] = Multiply(a, 0x0d) ^ Multiply(b, 0x09) ^ Multiply(c, 0x0e) ^ Multiply(d, 0x0b);
		state_[3][i] = Multiply(a, 0x0b) ^ Multiply(b, 0x0d) ^ Multiply(c, 0x09) ^ Multiply(d, 0x0e);
	}
}

void InvCipher_()
{
	int i, j, round = 0;

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			state_[j][i] = in_[i * 4 + j];
		}
	}

	AddRoundKey_(Nr_);

	for (round = Nr_ - 1; round > 0; round--)
	{
		InvShiftRows_();
		InvSubBytes_();
		AddRoundKey_(round);
		InvMixColumns_();
	}

	InvShiftRows_();
	InvSubBytes_();
	AddRoundKey_(0);

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			out_[i * 4 + j] = state_[j][i];
		}
	}
}

int core_decrypt(wchar_t CHarr[], int byte_col, char key_c[])
{
	//количество двойных слэшей
	int sp = 0;
	//длинна 
	int len = 0;

	for (int i = 0; CHarr[i] != '\0'; i++)
	{
		len++;
		if (CHarr[i] == '\\') sp++;
	}

	//строка пути хранения исходного файла
	char* str;
	str = (char*)malloc(len - sp);

	for (int i = 0; ; i++)
	{
		if (CHarr[i] == '\\') str[i] = '/';
		else if (CHarr[i] == '\0')
		{
			str[i] = '\0';
			break;
		}
		else str[i] = CHarr[i];
	}
	if (str == "") return 1;
	if (str[0] == '\0') return 1;
	//получили правильную строку
	errno_t err;
	FILE *mf;
	err = fopen_s(&mf, str, "rb");
	if (err != 0) return 1;

	//расшифрованный файл , конечный
	char* str_save;
	str_save = (char*)malloc(sizeof(char)*(strlen(str) - 6));
	int ffe = strlen(str) - 6;
	for (int i = 0; i < (strlen(str) - 6); i++)
	{
		str_save[i] = str[i];
		
	}
	str_save[ffe] = '\0';

	int pos = 0;
	for (pos = strlen(str_save); pos > 0; pos--)
		if (str_save[pos] == '/') break;

	if (pos != 0)
	{

		int i = 0;
		for ( i = pos + 1; i < strlen(str_save); i++)
			str[i-pos - 1] = str_save[i];
		str[i - pos -1 ] = '\0';

		str_save[pos+1] = 'd';
		str_save[pos+2] = 'e';
		str_save[pos+3] = 'c';
		str_save[pos+4] = 'r';
		str_save[pos+5] = 'y';
		str_save[pos+6] = 'p';
		str_save[pos+7] = 't';
		str_save[pos+8] = 'o';
		str_save[pos+9] = '_';

		for (i = 0; i < strlen(str); i++)
			str_save[pos + 10 + i] = str[i];
		str_save[pos + i + 10] = '\0';
	}

	FILE *crypt;//конечный файл
	errno_t err_cr;
	err_cr = fopen_s(&crypt, str_save, "wb+");
	if (err_cr != 0) return 1;

	Nr_ = byte_col;//128;//192, 256 Длинна ключа в битах . 

	Nk_ = Nr_ / 32;
	Nr_ = Nk_ + 6;

	unsigned char temp[32] = { 0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x0a  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00
							  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00  ,0x0a  ,0x00  ,0x00  ,0x00  ,0x00  ,0x00 };

	for (int i = 0; i < strlen(key_c); i++)
	{
		temp[i] = key_c[i];
	}

	for (int i = 0; i < Nk_ * 4; i++)
	{
		Key_[i] = temp[i];
	}

	//текст на расшифровку буфера из двух массивов 
	unsigned char temp2[16] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
	unsigned char temp3[16] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

	int i_f_c;//считываемый байт
	unsigned int num = 0;//счетчик байтов для буферов
	unsigned int ne = 0;
	unsigned int l_b = 0;//количество лишних байт в предпоследнем буфере\блоке

	fseek(mf, -1L, SEEK_END);
	l_b = getc(mf);
	rewind(mf);
	while ((i_f_c = getc(mf)) != EOF)
	{
		if (ne == 0) temp2[num] = i_f_c;
		else if (ne == 1) temp3[num] = i_f_c;
		num++;
		if (num == 16 & ne == 0) 
		{
			ne++;
			num = 0;
		}
		else if (num == 16 & ne == 1) 
		{
			int chk = 0;
			fseek(mf, 1L, SEEK_CUR);
			chk = getc(mf);
			if ((chk) != EOF)
			{
				fseek(mf, -2L, SEEK_CUR);
				for (int i = 0; i < 16; i++)
				{
					in_[i] = temp2[i];
				}
				KeyExpansion_();
				InvCipher_();
				for (int i = 0; i < 16; i++)
				{
					putc(out_[i], crypt);
				}

				for (int i = 0; i < 16; i++)
				{
					in_[i] = temp3[i];
				}
				KeyExpansion_();
				InvCipher_();
				for (int i = 0; i < 16; i++)
				{
					putc(out_[i], crypt);
				}
				ne = 0;
				num = 0;
			}
			else if ((chk ) == EOF)
			{
				fseek(mf, -2L, SEEK_CUR);

				for (int i = 0; i < 16; i++)
				{
					in_[i] = temp2[i];
				}
				KeyExpansion_();
				InvCipher_();
				for (int i = 0; i < 16; i++)
				{
					putc(out_[i], crypt);
				}

				for (int i = 0; i < 16; i++)
				{
					temp2[i] = temp3[i];
				}

				num = 0;
				ne = 1;
			}
		}
	}
	
	if (l_b == 0) 
	{
		for (int i = 0; i < 16; i++)
		{
			in_[i] = temp2[i];
		}
		KeyExpansion_();
		InvCipher_();
		for (int i = 0; i < 16; i++)
		{
			putc(out_[i], crypt);
		}
	}
	else 
	{
		for (int i = 0; i < 16; i++)
		{
			in_[i] = temp2[i];
		}
		KeyExpansion_();
		InvCipher_();
		for (int i = 0; i < 16 - l_b; i++)
		{
			putc(out_[i], crypt);
		}
	}


	//if ((i_f_c = ftell(mf)) == -1L) i_f_c = 0;

	fclose(mf);
	fclose(crypt);
	return 0;
}